autoload Cairo;

namespace Chrome {
    import Cairo;
    
    /*
     * Event types
     */
    public typedef enum { press, release, double, triple } button_type_t;
    
    public typedef struct {
	button_type_t	type;
	int		time;
	int		button;
	real		x;
	real		y;
    } button_event_t;

    public typedef enum { inside, entering, leaving } motion_type_t;
    
    public typedef struct {
	motion_type_t	type;
	int		time;
	real		x;
	real		y;
    } motion_event_t;
    
    public typedef enum { press, release } key_type_t;
    
    public typedef struct {
	key_type_t	type;
	int		time;
	string		key;
	string		text;
    } key_event_t;
    
    public typedef chrome_t;

    public typedef widget_t;

    public typedef void(cairo_t cr, &widget_t widget) draw_t;

    public typedef void(&widget_t, &button_event_t) button_handler_t;
    public typedef void(&widget_t, &motion_event_t) motion_handler_t;
    public typedef void(&widget_t, &key_event_t) key_handler_t;

    /*
     * Widgets, as seen by the toolkit
     */
    public typedef struct {
	rect_t		    rect;
	draw_t		    outline;
	draw_t		    draw;
	button_handler_t    button;
	motion_handler_t    motion;
	key_handler_t	    key;
	&chrome_t	    chrome;
    } widget_t;

    public typedef struct {
	surface_t	    surface;
	file		    event;
	bool		    draw;
	(&widget_t)[...]    widgets;
	&widget_t	    key_focus;
	&widget_t	    mouse_focus;
    } chrome_t;

    public widget_t no_widget;

    public namespace Widget {
	public void init (&chrome_t chrome, &widget_t widget) {
	    widget.rect = (rect_t) { x = 0, y = 0, width = 3, height = 1 };
	    &widget.chrome = &chrome;
	}
	public void redraw (&widget_t widget) {
	    widget.chrome.draw = true;
	}
	public string default_font = sprintf ("sans-%f", 12 / 28.45);
    }

    real dots_per_cm (cairo_t cr) = 37.8;
    
    cairo_t cairo (&chrome_t chrome)
    {
	cairo_t cr = create (chrome.surface);
	real res = dots_per_cm (cr);
	scale (cr, res, res);
	return cr;
    }
    
    bool rect_contains (&rect_t rect, real x, real y) {
	return (rect.x <= x && x < rect.x + rect.width &&
		rect.y <= y && y < rect.y + rect.height);
    }

    *widget_t xy_to_widget (&chrome_t chrome, real x, real y) {
	if (&chrome.mouse_focus != &no_widget)
	    return &chrome.mouse_focus;

	cairo_t cr = cairo (&chrome);

	point_t a = device_to_user (cr, (point_t) { x = x, y = y });
	destroy (cr);
	x = a.x; y = a.y;
	for (int w = 0; w < dim (chrome.widgets); w++) {
	    &widget_t widget = &chrome.widgets[w];
	    if (rect_contains (&widget.rect, x, y))
	    {
		return &widget;
	    }
	}
	return &no_widget;
    }

    public void dispatch_button (&chrome_t chrome, &button_event_t event) {
	&widget_t   widget = xy_to_widget (&chrome, event.x, event.y);

	if (&widget != &no_widget) {
	    if (event.type == button_type_t.press)
		&chrome.mouse_focus = &widget;
	    if (!is_uninit (&widget.button))
	    {
		widget.button (&widget, &event);
	    }
	    if (event.type == button_type_t.release)
		&chrome.mouse_focus = &no_widget;
	} else
	    &chrome.mouse_focus = &no_widget;
    }

    public void dispatch_motion (&chrome_t chrome, &motion_event_t event) {
	&widget_t   widget = xy_to_widget (&chrome, event.x, event.y);

	if (&widget != &no_widget)
	    if (!is_uninit (&widget.motion))
		widget.motion (&widget, &event);
    }

    public void dispatch_key (&chrome_t chrome, &key_event_t event) {
	&widget_t   widget = &chrome.key_focus;

	if (&widget != &no_widget)
	    if (!is_uninit (&widget.key))
		widget.key (&widget, &event);
    }

    public void set_key_focus (&chrome_t chrome, &widget_t widget) {
	&chrome.key_focus = &widget;
    }

    string hex_utf8 (int[...] bytes)
    {
	string	s = "";
	for (int i = 0; i < dim (bytes); i++) {
	    int first = bytes[i];
	    int c;
	    int extra = 0;
	    if ((first & 0x80) == 0) {
		c = first;
	    } else if ((first & 0xc0) != 0xc0) {
		c = first;
	    } else {
		int mask = 0x40;
		while ((first & mask) != 0)
		{
		    extra++;
		    mask >>= 1;
		}
		c = first & (mask - 1);
		while (i < dim (bytes) && extra-- > 0)
		    c = c << 6 | (bytes[i++] & 0x3f);
	    }
	    s += String::new (c);
	}
	return s;
    }

    void draw (&chrome_t chrome) {
	while (chrome.draw)
	{
	    chrome.draw = false;
	    cairo_t cr = cairo (&chrome);
	    int	i;
    
	    disable (cr);
	    set_source_rgba (cr, 1, 1, 1, 1);
	    paint (cr);
	    for (i = dim (chrome.widgets) - 1; i >= 0; i--)
	    {
		&widget_t	widget = &chrome.widgets[i];
		if (!is_uninit (&widget.draw)) {
		    save (cr);
		    translate (cr, widget.rect.x, widget.rect.y);
		    widget.draw (cr, &widget);
		    restore (cr);
		}
	    }
	    enable (cr);
	    destroy (cr);
	}
    }
    
    public chrome_t new () {
	chrome_t chrome;
	
	chrome.surface = Cairo::Surface::create_window ("Chrome",
							300, 300),
	chrome.event = Cairo::Surface::open_event (chrome.surface);
	chrome.draw = true;
	chrome.widgets = ((&widget_t)[...]) {};
	&chrome.key_focus = &no_widget;
	&chrome.mouse_focus = &no_widget;
	return chrome;
    }
    
    public void add (&chrome_t chrome, &widget_t widget) {
	&chrome.widgets[dim(chrome.widgets)] = &widget;
	chrome.draw = true;
    }

    public exception unknown_widget (&chrome_t chrome, &widget_t widget);
    
    int widget_pos (&chrome_t chrome, &widget_t widget) {
	for (int i = 0; i < dim(chrome.widgets); i++)
	    if (&chrome.widgets[i] == &widget)
		return i;
	raise unknown_widget (&chrome, &widget);
    }

    public void remove (&chrome_t chrome, &widget_t widget) {
	for (int i = widget_pos (&chrome, &widget); 
	     i < dim(chrome.widgets) - 1;
	     i++)
	{
    	    &chrome.widgets[i] = &chrome.widgets[i + 1];
	}
	setdim (chrome.widgets, dim(chrome.widgets) - 1);
	chrome.draw = true;
    }

    public void top (&chrome_t chrome, &widget_t widget) {
	for (int i = widget_pos (&chrome, &widget);
	     i > 0;
	     i--)
	{
	    &chrome.widgets[i] = &chrome.widgets[i-1];
	}
	&chrome.widgets[0] = &widget;
	chrome.draw = true;
    }
    
    public void main_loop (&chrome_t chrome) {
	bool	running = true;

	while (running) {
	    if (chrome.draw)
		draw (&chrome);
	    if (File::end (chrome.event))
		break;
	    string line = File::fgets (chrome.event);
	    file l = File::string_read (line);

	    File::fscanf (l, "%d %s", &(int time), &(string name));

	    switch (name) {
	    case "press":
	    case "release":
	    case "double-press":
	    case "triple-press":
		File::fscanf (l, "%d %g %g", &(int button),
			      &(real x), &(real y));
		button_event_t bev = {
		    type = ((button_type_t[string]) {
			"press" => button_type_t.press,
			"release" => button_type_t.release,
			"double-press" => button_type_t.double,
			"triple-press" => button_type_t.triple }) [name],
		    time = time,
		    button = button,
		    x = x,
		    y = y };
		dispatch_button (&chrome, &bev);
		break;
	    case "motion":
		File::fscanf (l, "%g %g", &(real x), &(real y));
		motion_event_t mev = {
		    type = motion_type_t.inside,
		    time = time,
		    x = x,
		    y = y };
		dispatch_motion (&chrome, &mev);
		break;
	    case "key-down":
	    case "key-up":
		File::fscanf (l, "%s", &(string keyname));
		int[...] bytes = {};
		while (File::fscanf (l, "%02x", &(int byte)) == 1)
		    bytes[dim(bytes)] = byte;
		string s = hex_utf8(bytes);
		key_event_t kev = {
		    type = (key_type_t[string]) {
			"key-down" => key_type_t.press,
			"key-up" => key_type_t.release } [name],
		    time = time,
		    key = keyname,
		    text = s };
		dispatch_key (&chrome, &kev);
		break;
	    }
	}
    }
}
