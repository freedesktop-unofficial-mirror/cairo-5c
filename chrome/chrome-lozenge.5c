/*
 * Copyright Â© 2008 Keith Packard
 *
 * This library is free software; you can redistribute it and/or
 * modify it either under the terms of the GNU Lesser General Public
 * License version 2.1 as published by the Free Software Foundation
 * (the "LGPL") or, at your option, under the terms of the Mozilla
 * Public License Version 1.1 (the "MPL"). If you do not alter this
 * notice, a recipient may use your version of this file under either
 * the MPL or the LGPL.
 *
 * You should have received a copy of the LGPL along with this library
 * in the file COPYING-LGPL-2.1; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 * You should have received a copy of the MPL along with this library
 * in the file COPYING-MPL-1.1
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
 * OF ANY KIND, either express or implied. See the LGPL or the MPL for
 * the specific language governing rights and limitations.
 *
 * The Original Code is the cairo graphics library.
 *
 * The Initial Developer of the Original Code is Keith Packard
 *
 * Contributor(s):
 *      Keith Packard <keithp@keithp.com>
 */

autoload Chrome;
autoload Chrome::Button;

extend namespace Chrome {
    public namespace Lozenge {
	
	public import Button;

	void lozenge (cairo_t cr, int width, int height, rgba_color_t color,
		      int highlight)
	{
	    save (cr);
	    rgba_color_t illum (rgba_color_t c, real add) {
		return (rgba_color_t) {
		    red = max (min (c.red + add, 1), 0),
		    green = max (min (c.green + add, 1), 0),
		    blue = max (min (c.blue + add, 1), 0),
		    alpha = c.alpha };
	    }

	    rgba_color_t interp (rgba_color_t l, rgba_color_t r, real ratio)
	    {
		return (rgba_color_t) {
		    red = l.red * (1-ratio) + r.red * ratio,
		    green = l.green * (1-ratio) + r.green * ratio,
		    blue = l.blue * (1-ratio) + r.blue * ratio,
		    alpha = l.alpha * (1-ratio) + r.alpha * ratio };
	    }
	    height = height & ~1;
	    int    radius = height / 2;
	    real    add = .3;
	    move_to (cr, radius, height);
	    arc (cr, radius, radius, radius, pi/2, -pi/2);
	    line_to (cr, width - radius, 0);
	    arc (cr, width - radius, radius, radius, -pi/2, pi/2);
	    close_path (cr);
	    clip (cr);

	    rgba_color_t light = color;
	    rgba_color_t lighter = illum (light, add);
	    rgba_color_t medium = light;
	    rgba_color_t darker = illum (light, -add);
 
	    pattern_t pat = Pattern::create_radial (radius + highlight,
						    radius + highlight,
						    0,
						    radius + highlight,
						    radius + highlight,
						    radius);
	    Pattern::add_color_stop_rgba (pat, 0, lighter.red, lighter.green,
					  lighter.blue, lighter.alpha);
	    Pattern::add_color_stop_rgba (pat, 0.5, medium.red, medium.green,
					  medium.blue, medium.alpha);

	    Pattern::add_color_stop_rgba (pat, 1, darker.red, darker.green,
					  darker.blue, darker.alpha);
	    set_source (cr, pat);
	    rectangle (cr, 0, 0, radius + highlight, height);
	    fill (cr);

	    pattern_t pat = Pattern::create_linear (0, highlight, 0,
						    height + highlight);
	    Pattern::add_color_stop_rgba (pat, 0, darker.red, darker.green,
					  darker.blue, darker.alpha);

	    Pattern::add_color_stop_rgba (pat, 0.25, medium.red, medium.green,
					  medium.blue, medium.alpha);

	    Pattern::add_color_stop_rgba (pat, 0.5, lighter.red, lighter.green,
					  lighter.blue, lighter.alpha);

	    Pattern::add_color_stop_rgba (pat, 0.75, medium.red, medium.green,
					  medium.blue, medium.alpha);

	    Pattern::add_color_stop_rgba (pat, 1, darker.red, darker.green,
					  darker.blue, darker.alpha);
	    set_source (cr, pat);

	    rectangle (cr, radius + highlight, 0, width - height, height);
	    fill (cr);

	    pattern_t pat = Pattern::create_radial (width - radius + highlight,
						    radius + highlight,
						    0,
						    width - radius + highlight,
						    radius + highlight,
						    radius);

	    Pattern::add_color_stop_rgba (pat, 0, lighter.red, lighter.green,
					  lighter.blue, lighter.alpha);
	    Pattern::add_color_stop_rgba (pat, 0.5, medium.red, medium.green,
					  medium.blue, medium.alpha);

	    Pattern::add_color_stop_rgba (pat, 1, darker.red, darker.green,
					  darker.blue, darker.alpha);
	    set_source (cr, pat);
	    rectangle (cr, width - radius + highlight, 0, radius - highlight, height);
	    fill (cr);
	    restore (cr);
	}
	
	public typedef button_t lozenge_t;
	
	public metrics_t get_metrics (cairo_t cr, &lozenge_t widget) {
	    set_font (cr, widget.font);
	    text_extents_t text = text_extents (cr, widget.label);
	    text_extents_t m = text_extents (cr, "M");
	    font_extents_t font = font_extents(cr);
	    metrics_t metrics;
	    
	    real pad = floor (widget.pad_ratio * -m.y_bearing + 0.5);
	    metrics.pad = pad;
	    metrics.preferred_height = floor (pad + m.height + pad + 1.5) & ~1;
	    metrics.preferred_width = floor (widget.pad_ratio * 2.5 * pad +
	    text.width + 0.5);
	    metrics.width = max (widget.geometry.width, metrics.preferred_width);
	    metrics.height = max (widget.geometry.height, metrics.preferred_height);
	    metrics.y = floor ((metrics.height + m.y_bearing) / 2 - m.y_bearing + 0.5);
	    metrics.x = floor ((metrics.width - text.width) / 2 + 0.5);
	    return metrics;
	}
	
	public void draw (cairo_t cr, &lozenge_t widget) {
	    metrics_t	metrics = widget.get_metrics (cr, &widget);
	    real    highlight = -floor (metrics.height/20);

	    if (widget.pressed)
		highlight = -highlight;

	    save (cr);
	    translate (cr, floor (metrics.pad/2), floor (metrics.pad/2));
	    lozenge (cr, floor (metrics.width - metrics.pad),
		     floor (metrics.height - metrics.pad),
		     widget.color, highlight);
	    restore (cr);
	    real text_x = metrics.x + highlight/2;
	    real text_y = metrics.y + highlight/2;
	    move_to (cr, text_x + 1, text_y + 1);
	    set_source_rgb (cr, .8, .8, .8);
	    show_text (cr, widget.label);
	    move_to (cr, text_x, text_y);
	    set_source_rgb (cr, 0, 0, 0);
	    show_text (cr, widget.label);
	}

	public void init (&lozenge_t widget,
			  &chrome_t chrome,
			  string label,
			  callback_t callback) {
	    Button::init (&widget, &chrome, label, callback);
	    widget.draw = draw;
	    widget.get_metrics = get_metrics;
	}
	
	public *widget_t new (&chrome_t chrome,
			      string label,
			      callback_t callback) {
	    lozenge_t	widget;

	    init (&widget, &chrome, label, callback);
	    return &widget;
	}
    }
}
